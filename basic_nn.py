# -*- coding: utf-8 -*-
"""RNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BLgNZf-bgQ5cbpak8n4bgwsaK4F-RNGU

Import librarires -> Load the Dataset -> Build neural network -> Train Network
"""

import torch
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms

"""Loading dataset"""

train_data = datasets.MNIST(
    root =  'data',
    train = True,
    transform = transforms.ToTensor(),
    download = True
)

test_data = datasets.MNIST(
    root =  'data',
    train = False,
    transform = transforms.ToTensor(),
    download = True
)

batch_size = 60

train_loader = DataLoader(
    dataset = train_data,
    batch_size = batch_size,
    shuffle = True
)

test_loader = DataLoader(
    dataset = test_data,
    batch_size = batch_size,
    shuffle = True
)

"""Building neural network"""

class NN(nn.Module):
  def __init__(self, input_size, num_classes):
    super(NN, self).__init__()
    self.fc1 = nn.Linear(input_size, 60) #hidden layers = 60
    self.fc2 = nn.Linear(60, num_classes)

  def forward(self, x):
    x = F.relu(self.fc1(x))
    x= self.fc2(x)
    return x

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu' )

"""defining parameters"""

input_size = 784 # 28*28
num_classes = 10
lr = 10e-4
epoch = 5

model = NN(input_size=input_size, num_classes = num_classes).to(device)

crietrion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr = lr)

"""Training"""

for ep in range(epoch):
  for batch_idx, (data, targets) in enumerate(train_loader):
    data = data.to(device=device)
    targets = targets.to(device=device)
    data = data.reshape(data.size(0), -1) # flattening: multiply the last 2 dimensions to give input size = 784
    scores = model(data) # giving model data
    loss = crietrion(scores, targets)
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()



"""Accuracy evaluation"""

def acc_check(loader, model):
  correct_ans = 0
  wrong_ans = 0
  with torch.no_grad():
    for x,y in loader:
      x = x.to(device)
      y = y.to(device)
      x = x.reshape(x.size(0),-1)
      val_scores = model(x)
      _, predction = val_scores.max(1)
      correct_ans += (predction == y).sum().item()
  return correct_ans/len(loader.dataset)

acc_score = acc_check(test_loader, model)
print(acc_score)